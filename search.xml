<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>策略工厂代码实现多种消息存入数据库</title>
      <link href="/2024/07/15/%E7%AD%96%E7%95%A5%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E6%B6%88%E6%81%AF%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/07/15/%E7%AD%96%E7%95%A5%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%A7%8D%E6%B6%88%E6%81%AF%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL常见优化手段</title>
      <link href="/2024/07/10/SQL%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/"/>
      <url>/2024/07/10/SQL%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL常见优化手段"><a href="#SQL常见优化手段" class="headerlink" title="SQL常见优化手段"></a>SQL常见优化手段</h1><p><img src="/./pic/SQlcacimage.png" alt="alt text"></p><h2 id="1-避免使用select"><a href="#1-避免使用select" class="headerlink" title="1.避免使用select *"></a>1.避免使用select *</h2><p>很多时候，我们写sql语句时，为了方便，喜欢直接使用select *，一次性查出表中所有列的数据。</p><p><b>反例</b>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from user <span class="built_in">where</span> <span class="built_in">id</span>=1;</span><br></pre></td></tr></table></figure><p>这种情况，出现的问题不仅仅是说查询了一些无用的字段，比如用户表要查询登录密码，但头像信息也返回给我了。</p><p>除此之外，我们的sql最大的问题还是<b>回表</b>问题。</p><p><b>什么是回表问题？</b></p><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>我们都知道mysql数据库中默认的两张表，innodb和myisam。</p><p>回表行为就出现在了innodb表中，而myisam不会出现，这是为什么？让我们看看这两个存储引擎的内部结构。<br><img src="/./pic/huibioadasimage.png" alt="alt text"></p><p>从图中我们可以清晰的看出来，innodb是通过主键索引查询树节点数据，而myisam则是通过寻找数据的地址来查询数据。</p><p>现在我们来解释一下聚簇索引和非聚簇索引（辅助键索引）。</p><p>聚簇索引：一个innodb表只能由一个聚簇索引键，默认就是主键id，但是如果没有id呢？那么innodb找字段中只有唯一值的那个键，类似于名字如果能保证所有人都不相同，那么它会成为下一个聚簇索引键，如果都没有，就用隐藏字段，innodb内置好了。</p><p>非聚簇索引（辅助键索引）：除了主键索引以外的其他索引。</p><p>我们查询name的时候，那么辅助键索引会回表查询，先去找主键id然后再去找数据。</p><p>使用覆盖索引可以解决上面所说的回表的问题。还是拿上面上面登录的例子来说，其实登录只需要判断用户名和密码，如果user表中有其他用户信息也是不需要的那我们能不能只查询一次就找到这个用户名对应的密码呢。这个是可以的，上面所说的分两步查找，第一步根据username查找是肯定不能少的，那我们只要把password和索引username放到一起就可以了。我们可以建立一个（username、password）的组合索引，这里username一定要放在前面，然后我们把sql语句改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age from user <span class="built_in">where</span> <span class="built_in">id</span>=1;</span><br><span class="line"><span class="keyword">select</span> username, password FROM user WHERE username = <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT password FROM user WHERE username = <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-用union-all-代替-union"><a href="#2-用union-all-代替-union" class="headerlink" title="2.用union all 代替 union"></a>2.用union all 代替 union</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> * from user <span class="built_in">where</span> <span class="built_in">id</span>=1) </span><br><span class="line">union </span><br><span class="line">(<span class="keyword">select</span> * from user <span class="built_in">where</span> <span class="built_in">id</span>=2);</span><br></pre></td></tr></table></figure><p>排重的过程耗时间，所以能用union all 尽量用除非特殊情况。</p><h2 id="3-小表驱动大表"><a href="#3-小表驱动大表" class="headerlink" title="3.小表驱动大表"></a>3.小表驱动大表</h2><p>小表驱动大表，也就是说用小表的数据集驱动大表的数据集。</p><p>假如有order和user两张表，其中order表有10000条数据，而user表有100条数据。</p><p>这时如果想查一下，所有有效的用户下过的订单列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from order</span><br><span class="line"><span class="built_in">where</span> user_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">id</span> from user <span class="built_in">where</span> status=1)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from user</span><br><span class="line"><span class="built_in">where</span> exists (<span class="keyword">select</span> 1 from order <span class="built_in">where</span> user.id = user.user.id and status=1)</span><br></pre></td></tr></table></figure><p>前面提到的这种业务场景，使用in关键字去实现业务需求，更加合适。</p><p>为什么呢？</p><p>因为如果sql语句中包含了in关键字，则它会优先执行in里面的子查询语句，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。</p><p>而如果sql语句中包含了exists关键字，它优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。</p><p>这个需求中，order表有10000条数据，而user表有100条数据。order表是大表，user表是小表。如果order表在左边，则用in关键字性能更好。</p><p>总结一下：</p><ol><li><p>in 适用于左边大表，右边小表。</p></li><li><p>exists 适用于左边小表，右边大表。</p></li></ol><p>不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。</p><h3 id="4-批量操作"><a href="#4-批量操作" class="headerlink" title="4.批量操作"></a>4.批量操作</h3><p>如果你有一批数据经过业务处理之后，需要插入数据，该怎么办？</p><p><b>反例</b>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Order order: list)&#123;</span><br><span class="line">   orderMapper.insert(order):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环中逐条插入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into order(<span class="built_in">id</span>,code,user_id)  values (123,<span class="string">&#x27;001&#x27;</span>,100);</span><br></pre></td></tr></table></figure><p>该操作需要多次请求数据库，才能完成这批数据的插入。</p><p>但众所周知，我们在代码中，每次远程请求数据库，是会消耗一定性能的。而如果我们的代码需要请求多次数据库，才能完成本次业务功能，势必会消耗更多的性能。</p><p>那么如何优化呢？</p><p><b>正例：</b>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderMapper.insertBatch(list):</span><br></pre></td></tr></table></figure><p>提供一个批量插入数据的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into order(<span class="built_in">id</span>,code,user_id) </span><br><span class="line">values(123,<span class="string">&#x27;001&#x27;</span>,100),(124,<span class="string">&#x27;002&#x27;</span>,100),(125,<span class="string">&#x27;003&#x27;</span>,101);</span><br></pre></td></tr></table></figure><p>这样只需要远程请求一次数据库，sql性能会得到提升，数据量越多，提升越大。</p><p>但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。</p><h3 id="5-多用limit"><a href="#5-多用limit" class="headerlink" title="5.多用limit"></a>5.多用limit</h3><p>有时候，我们需要查询某些数据中的第一条，比如：查询某个用户下的第一个订单，想看看他第一次的首单时间。</p><p><b>反例：</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">id</span>, create_date </span><br><span class="line"> from order </span><br><span class="line"><span class="built_in">where</span> user_id=123 </span><br><span class="line">order by create_date asc;</span><br></pre></td></tr></table></figure><p>根据用户id查询订单，按下单时间排序，先查出该用户所有的订单数据，得到一个订单集合。然后在代码中，获取第一个元素的数据，即首单的数据，就能获取首单时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Order&gt; list = orderMapper.getOrderList();</span><br><span class="line">Order order = list.get(0);</span><br></pre></td></tr></table></figure><p>虽说这种做法在功能上没有问题，但它的效率非常不高，需要先查询出所有的数据，有点浪费资源。</p><p>那么，如何优化呢？</p><p><b>正例：</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">elect <span class="built_in">id</span>, create_date </span><br><span class="line"> from order </span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> user_id=123 </span><br><span class="line"></span><br><span class="line">order by create_date asc </span><br><span class="line"></span><br><span class="line"><span class="built_in">limit</span> 1;</span><br></pre></td></tr></table></figure><p>使用limit 1，只返回该用户下单时间最小的那一条数据即可。</p><p>此外，在删除或者修改数据时，为了防止误操作，导致删除或修改了不相干的数据，也可以在sql语句最后加上limit。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update order <span class="built_in">set</span> status=0,edit_time=now(3) </span><br><span class="line"><span class="built_in">where</span> <span class="built_in">id</span>&gt;=100 and <span class="built_in">id</span>&lt;200 <span class="built_in">limit</span> 100;</span><br></pre></td></tr></table></figure><p>这样即使误操作，比如把id搞错了，也不会对太多的数据造成影响。</p><h3 id="6-SQL查找是否”存在”，别再count了！"><a href="#6-SQL查找是否”存在”，别再count了！" class="headerlink" title="6.SQL查找是否”存在”，别再count了！"></a>6.SQL查找是否”存在”，别再count了！</h3><h4 id="SQL查找是否”存在”，别再count了！"><a href="#SQL查找是否”存在”，别再count了！" class="headerlink" title="SQL查找是否”存在”，别再count了！"></a>SQL查找是否”存在”，别再count了！</h4><p>根据某一条件从数据库表中查询 『有』与『没有』，只有两种状态，那为什么在写SQL的时候，还要SELECT count(*) 呢？</p><p>无论是刚入道的程序员新星，还是精湛沙场多年的程序员老白，都是一如既往的count</p><p>反例：目前多数人的写法</p><p>多次REVIEW代码时，发现如现现象：</p><p>业务代码中，需要根据一个或多个条件，查询是否存在记录，不关心有多少条记录。普遍的SQL及代码写法如下</p><p> <b>SQL写法 </b></p><p>SELECT count(*) FROM table WHERE a &#x3D; 1 AND b &#x3D; 2</p><h4 id="Java写法"><a href="#Java写法" class="headerlink" title="Java写法:"></a>Java写法:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int nums = xxDao.countXxxxByXxx(params);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( nums &gt; 0 ) &#123;</span><br><span class="line"></span><br><span class="line">  //当存在时，执行这里的代码</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  //当不存在时，执行这里的代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是不是感觉很OK，没有什么问题<br>优化方案<br>推荐写法如下：</p><p><b>SQL写法: </b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 FROM table WHERE a = 1 AND b = 2 LIMIT 1</span><br></pre></td></tr></table></figure><p> <b>Java写法: </b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer exist = xxDao.existXxxxByXxx(params);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( exist != NULL ) &#123;</span><br><span class="line"></span><br><span class="line">  //当存在时，执行这里的代码</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  //当不存在时，执行这里的代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL不再使用count，而是改用LIMIT 1，让数据库查询时遇到一条就返回，不要再继续查找还有多少条了</p><p>业务代码中直接判断是否非空即可</p><p>总结<br>根据查询条件查出来的条数越多，性能提升的越明显，在某些情况下，还可以减少联合索引的创建。’</p><h3 id="7-高效的分页-游标分页"><a href="#7-高效的分页-游标分页" class="headerlink" title="7.高效的分页(游标分页)"></a>7.高效的分页(游标分页)</h3><p>有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。</p><p>在mysql中分页一般用的limit关键字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">id</span>,name,age </span><br><span class="line">from user <span class="built_in">limit</span> 10,20;</span><br></pre></td></tr></table></figure><p>如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。</p><p>比如现在分页参数变成了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">id</span>,name,age </span><br><span class="line">from user <span class="built_in">limit</span> 1000000,20;</span><br></pre></td></tr></table></figure><p>mysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。</p><p>那么，这种海量数据该怎么分页呢？</p><p>优化sql：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">id</span>,name,age </span><br><span class="line">from user <span class="built_in">where</span> <span class="built_in">id</span> &gt; 1000000 <span class="built_in">limit</span> 20;</span><br></pre></td></tr></table></figure><p>先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。</p><p>还能使用between优化分页。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">id</span>,name,age </span><br><span class="line">from user <span class="built_in">where</span> <span class="built_in">id</span> between 1000000 and 1000020;</span><br></pre></td></tr></table></figure><p>需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。</p><h3 id="8-用连接查询代替子查询"><a href="#8-用连接查询代替子查询" class="headerlink" title="8 用连接查询代替子查询"></a>8 用连接查询代替子查询</h3><p>mysql中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：子查询 和 连接查询。</p><p>子查询的例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from order</span><br><span class="line"><span class="built_in">where</span> user_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">id</span> from user <span class="built_in">where</span> status=1)</span><br></pre></td></tr></table></figure><p>子查询语句可以通过in关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序先运行在嵌套在最内层的语句，再运行外层的语句。</p><p>子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。</p><p>但缺点是mysql执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。</p><p>这时可以改成连接查询。具体例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.* from order o</span><br><span class="line">inner <span class="built_in">join</span> user u on o.user_id = u.id</span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> u.status=1</span><br></pre></td></tr></table></figure><h3 id="9-join的表不宜过多"><a href="#9-join的表不宜过多" class="headerlink" title="9 join的表不宜过多"></a>9 join的表不宜过多</h3><p>根据阿里巴巴开发者手册的规定，join表的数量不应该超过3个</p><p>因为mysql不知道怎么选择索引,尽量越少越好。</p><h3 id="10-join时要注意"><a href="#10-join时要注意" class="headerlink" title="10 join时要注意"></a>10 join时要注意</h3><p>我们在涉及到多张表联合查询的时候，一般会使用join关键字。</p><p>而join使用最多的是left join和inner join。</p><p>left join：求两个表的交集外加左表剩下的数据。</p><p>inner join：求两个表交集的数据。</p><p>使用inner join的示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.id,o.code,u.name </span><br><span class="line">from order o </span><br><span class="line"></span><br><span class="line">inner <span class="built_in">join</span> user u on o.user_id = u.id</span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> u.status=1;</span><br></pre></td></tr></table></figure><p>如果两张表使用inner join关联，mysql会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题。</p><p>使用left join的示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.id,o.code,u.name </span><br><span class="line">from order o </span><br><span class="line"></span><br><span class="line">left <span class="built_in">join</span> user u on o.user_id = u.id</span><br><span class="line"></span><br><span class="line"><span class="built_in">where</span> u.status=1;</span><br></pre></td></tr></table></figure><p>如果两张表使用left join关联，mysql会默认用left join关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题。</p><p>要特别注意的是在用left join关联查询时，左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简历知识 </tag>
            
            <tag> sql </tag>
            
            <tag> mysql </tag>
            
            <tag> mysql优化方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVCC的原理以及运行</title>
      <link href="/2024/07/09/MVCC%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C/"/>
      <url>/2024/07/09/MVCC%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><h2 id="MVCC简介"><a href="#MVCC简介" class="headerlink" title="MVCC简介"></a>MVCC简介</h2><h3 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h3><p>MVCC的意思是多版本控制，目的是为了解决高并发带来数据读取问题。</p><h3 id="为什么我们需要MVCC"><a href="#为什么我们需要MVCC" class="headerlink" title="为什么我们需要MVCC"></a>为什么我们需要MVCC</h3><p>原来的防止数据出现读取问题的方案是通过数据库锁的方式，这种方式的缺点就是会锁住数据运行通道，对数据的运行速度有很大的阻碍，而MVCC是一种理念无锁模式，可以在高并发的同时保证数据的准确和统一。</p><h2 id="脏读，可重复读，幻影读"><a href="#脏读，可重复读，幻影读" class="headerlink" title="脏读，可重复读，幻影读"></a>脏读，可重复读，幻影读</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><img src="/./pic/imagezangdu.png" alt="alt text"><br>假设有两个事务同时进入，并发请求，事务一把值修改成八百，但是修改失败了，事务回滚，此时事务二读取到的数据就是脏读。</p><p>简而言之，就是在事务并发执行的时候，如果事务一未结束，修改的数据并未确定值，有可能造成事务二读取到错误的数据。</p><h3 id="不可重复读（也叫可重复读）"><a href="#不可重复读（也叫可重复读）" class="headerlink" title="不可重复读（也叫可重复读）"></a>不可重复读（也叫可重复读）</h3><p><img src="/./pic/bukechongduimage.png" alt="alt text"></p><p>也是假设有两个事务并发执行，事务一还没执行完，需要读取两次值的时候，此时事务二把值改了，获取的结果不同，值无法重复读取。</p><p>在这里要强调一点，重复读和幻影读很像，但只是范围不同，重复读的范围在单表某条数据中，但幻影读在单表上面，比如数据条数对不上之类的。</p><h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p><img src="/./pic/huanyingduimage.png" alt="alt text"></p><p>幻影读是对整张表来说，结果不同，和不可重复读有相似性，但是幻影读特定针对表，而不可重复读特定针对数据行列。</p><p>再加一个区别，幻影读和不可重复读的主要区别在于，不可重复度读的是数据，幻影读，读的是数据的记录行数。</p><p>注意！：MVCC是快照读，相对于传统的可重复读来说，MVCC具有快照的性质，幻影读在修改数据的时候，MVCC可以解决，但是在增添数据的时候，MVCC不能解决只能用传统的当前读情况下使用（记录锁+间隙锁）来解决这个问题。</p><h2 id="MVCC的原理以及用处"><a href="#MVCC的原理以及用处" class="headerlink" title="MVCC的原理以及用处"></a>MVCC的原理以及用处</h2><h3 id="MVCC的原理"><a href="#MVCC的原理" class="headerlink" title="MVCC的原理"></a>MVCC的原理</h3><p><img src="/./pic/mvccylimage.png" alt="alt text"><br>首先我们要知道数据库中的数据行并不是只是我们明面上看到的那样，还有三个隐藏列，第一个隐藏列叫DB_TRX_ID，这个是用来定义事务id的，如果我们有一个插入的事务，这个列就会把这个插入的事务id保存进来。</p><p>第二列DB_ROLL_PTR则是存储老数据位置的指针，如果新的数据呗更新，新数据的这个列会存储老数据的这个地址做到指引作用。</p><p>第三个隐藏列不重要在这里，因为他是在我们没有维护主键id的时候出现的，为我们每个列维护一个唯一的值。</p><p>有了这个基础，那么我们来看看MVCC是怎么实现的吧</p><p><img src="/./pic/prcc1image.png" alt="alt text"><br><img src="/./pic/prcc2image.png" alt="alt text"></p><p>我们来看这三张图，让我先来介绍一下MVCC的两个重要模块。</p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>这个模块的作用就是在高并发事务进来的时候，给每个事务的id进行记录，先获得当前事务id，然后呢获取所有已经提交事务的id，并且按照从小到大排序，最后呢获取一个还没有开始的事务id。</p><p>这三个构成了我们ReadView板块，那么他们是如何在MVCC中使用的呢？</p><p>我们还需要下面这个模块undolog</p><h4 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h4><p><img src="/./pic/udlohgimage.png" alt="alt text"><br>undolog是什么呢，undolog指的是RollPTR这个列中存储的老数据的集合表。</p><h3 id="MVCC的运行逻辑"><a href="#MVCC的运行逻辑" class="headerlink" title="MVCC的运行逻辑"></a>MVCC的运行逻辑</h3><p>首先我们搞懂我们的目的是什么，我们需要的是事务在读取到时候，不会去读取别的并发线程没有做完的操作，而是读取已经提交的事务！！！这点很重要，理解这点我们再来看。</p><p>我们当前读的事务trx_id是20，而提交的事务trx_id是10。</p><p>有四个流程我们走一下。</p><ol><li><p>刚开始，事务10把数据b修改成800，但是没有提交，而且他说不定会回滚，所以事务20决不能去读这个800，不然就是脏读。所以我们会先比较当前trx_id(事务id)和这个值的trx_id(事务id)是否相同。如果不同的话，就走下一步停止读取。我们这里明显一个是10修改的数据，20来读,他所以不行。</p></li><li><p>然后执行第二步，判断当前事务trx_id(事务id)是不是小于最小trx_id(事务id)。如果小于，代表事务已经提交完毕，所以可以读取，但这里20明显大于最小值10。所以也不行。</p></li><li><p>然后执行第三部，如果当前trx_id(事务id20)大于我们存在ReadView中的未开始trxid的话，代表此时这个事务也属于未开始事务id，直接找上一条历史数据就行了，并且根据上一条历史数据再走一遍流程。我们这里明显20要小于21。</p></li><li><p>如果当前trx_id属于最小trx_id和最大trx_id之间，10到21之间的话，代表我们事务是属于未提交事务之中，所以我们要跳过所有未提交事务的数据，如上图所示的那个trx_id属于10到21之间的数据行。</p></li></ol><p>好了，现在流程走完了，我们可以知道在这个案例中，我们的事务id是20，前面三条都走不通，只能走第四条，第四条会直接找到数据上一条trx_id为初始化1的的时候，并且知道这条是已提交数据，因为我们在第二条判断了,trx_id&#x3D;1小于最小值10；</p><p>现在最后一个问题，如果四条都走不通怎么办？其实数据会根据四个条件再走一次，只不过这个数据指针会回到上一条，就是数据行现在是trx_id&#x3D;1的时候。</p><h3 id="MVCC要注意的一些点"><a href="#MVCC要注意的一些点" class="headerlink" title="MVCC要注意的一些点"></a>MVCC要注意的一些点</h3><p>MVCC只能解决读已经提交的数据，还有重复读（痔疮键一次ReadView）的问题，但是不能解决幻影读，和读未提交的数据的问题。</p><p>这两个问题只能用数据库锁中表锁或者行级锁来解决，因为如果出现幻影读（还记得我们前面知道他和重复读的区别在于是表级别还是行级别吗），只能用表来锁（因为会降低性能不到万不得已别用）。一个个事务执行，读取未提交的数据的时候呢，数据未提交代表着脏读的出现，这种时候我们只能尽量避免，因为他直接修改数据源的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简历知识 </tag>
            
            <tag> sql </tag>
            
            <tag> mysql </tag>
            
            <tag> mysql优化方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Innodb的四大特性你必须得会！</title>
      <link href="/2024/07/09/Innodb%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%BE%97%E4%BC%9A%EF%BC%81/"/>
      <url>/2024/07/09/Innodb%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%BE%97%E4%BC%9A%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<p>InnoDB四大特性</p><h3 id="1-自适应哈希索引："><a href="#1-自适应哈希索引：" class="headerlink" title="1. 自适应哈希索引："></a>1. 自适应哈希索引：</h3><p><img src="/./pic/1720504239756.jpg" alt="alt text"></p><p>我们都知道mysql的索引是根据B+树进行查询的，B+树的数据都i是放在了叶子节点上，而热点数据的查询占据我们数据库请求中的很大一部分，所以其实我们在热点数据上只需要做到一个哈希索引，直接找到那个数据所在的叶子节点，这样节省了每次查询都从第一个叶子节点开始查的时间。</p><h3 id="插入缓冲："><a href="#插入缓冲：" class="headerlink" title="插入缓冲："></a>插入缓冲：</h3><p><img src="/./pic/image.png" alt="alt text"></p><p>每次数据写到文件中去的时候，都是要通过一个io流的，我们可以把相同数据页的数据放在一个缓冲池当中然后一起写入，减少了IO流的时间。</p><h3 id="邻接表刷新："><a href="#邻接表刷新：" class="headerlink" title="邻接表刷新："></a>邻接表刷新：</h3><p><img src="/./pic/imagedasd.png" alt="alt text"></p><p>刷新邻接页，数据在修改了以后但是没进入文件当中（没有写入），我们称之为脏页，脏页需要刷新。文件是有分区的，不同的表会在不同的分区，也有可能有表会把数据写入一个分区内，而Innodb提供了一个操作。脏表刷新之前会检查自己的分区，innodb会把检查到同一个分区的表进行合并刷新。</p><h3 id="双写："><a href="#双写：" class="headerlink" title="双写："></a>双写：</h3><p><img src="/./pic/iasdmgaage.png" alt="alt text"></p><p>脏表写入的时候，有可能写到一半就寄了（悲！！！）。那怎么办呢？当然是Innodb会出手啦。它在数据库中会新建一张共享表空间，innodb先把数据写到了缓冲池，缓冲池先写数据到这张共享表空间，然后再写入文件，要是写到一半寄了，innodb从共享表空间拿剩下一半的数据。</p><p>总结：innodb四个特性，邻接表刷新，双写，插入缓冲，哈希索引</p>]]></content>
      
      
      
        <tags>
            
            <tag> 简历知识 </tag>
            
            <tag> sql </tag>
            
            <tag> mysql </tag>
            
            <tag> sql引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL常用语法</title>
      <link href="/2024/07/03/SQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/07/03/SQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql常见用法"><a href="#mysql常见用法" class="headerlink" title="mysql常见用法"></a>mysql常见用法</h1><h2 id="DDL（数据定义）"><a href="#DDL（数据定义）" class="headerlink" title="DDL（数据定义）"></a>DDL（数据定义）</h2><p>数据库操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 创建库</span><br><span class="line">create database db1;</span><br><span class="line">-- 创建库是否存在，不存在则创建</span><br><span class="line">create database <span class="keyword">if</span> not exists db1;</span><br><span class="line">-- 查看所有数据库</span><br><span class="line">show databases;</span><br><span class="line">-- 查看某个数据库的定义信息 </span><br><span class="line">show create database db1; </span><br><span class="line">-- 修改数据库字符信息</span><br><span class="line">alter database db1 character <span class="built_in">set</span> utf8; </span><br><span class="line">-- 删除数据库</span><br><span class="line">drop database db1; </span><br></pre></td></tr></table></figure><p>表的操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--创建表</span><br><span class="line">create table student(</span><br><span class="line">    <span class="built_in">id</span> int,</span><br><span class="line">    name varchar(32),</span><br><span class="line">    age int ,</span><br><span class="line">    score double(4,1),</span><br><span class="line">    birthday <span class="built_in">date</span>,</span><br><span class="line">    insert_time timestamp</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">-- 查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line">-- 查看创建表的SQL语句</span><br><span class="line">show create table 表名;</span><br><span class="line">-- 修改表名</span><br><span class="line">alter table 表名 rename to 新的表名;</span><br><span class="line">-- 添加一列</span><br><span class="line">alter table 表名 add 列名 数据类型;</span><br><span class="line">-- 删除列</span><br><span class="line">alter table 表名 drop 列名;</span><br><span class="line">-- 删除表</span><br><span class="line">drop table 表名;</span><br><span class="line">drop table  <span class="keyword">if</span> exists 表名 ;</span><br></pre></td></tr></table></figure><h2 id="DML-Data-Manipulation-Language-数据操作语言"><a href="#DML-Data-Manipulation-Language-数据操作语言" class="headerlink" title="DML(Data Manipulation Language)数据操作语言"></a>DML(Data Manipulation Language)数据操作语言</h2><p>增加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 写全所有列名</span><br><span class="line">insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);</span><br><span class="line">-- 不写列名（所有列全部添加）</span><br><span class="line">insert into 表名 values(值1,值2,...值n);</span><br><span class="line">-- 插入部分数据</span><br><span class="line">insert into 表名(列名1,列名2) values(值1,值2);</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 删除表中数据</span><br><span class="line">delete from 表名 <span class="built_in">where</span> 列名  = 值;</span><br><span class="line">-- 删除表中所有数据</span><br><span class="line">delete from 表名;</span><br><span class="line">-- 删除表中所有数据（高效 先删除表，然后再创建一张一样的表。）</span><br><span class="line"><span class="built_in">truncate</span> table 表名;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 不带条件的修改(会修改所有行)</span><br><span class="line">update 表名 <span class="built_in">set</span> 列名 = 值;</span><br><span class="line">-- 带条件的修改</span><br><span class="line">update 表名 <span class="built_in">set</span> 列名 = 值 <span class="built_in">where</span> 列名=值;</span><br></pre></td></tr></table></figure><h2 id="DQL-Data-Query-Language-数据查询语言"><a href="#DQL-Data-Query-Language-数据查询语言" class="headerlink" title="DQL(Data Query Language)数据查询语言"></a>DQL(Data Query Language)数据查询语言</h2><h3 id="一-基础关键字"><a href="#一-基础关键字" class="headerlink" title="一 基础关键字"></a>一 基础关键字</h3><p>BETWEEN…AND （在什么之间）和  IN( 集合)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 查询年龄大于等于20 小于等于30</span><br><span class="line"><span class="keyword">select</span> * from Student <span class="built_in">where</span> age &gt;= 20 &amp;&amp; age&lt;=30</span><br><span class="line"><span class="keyword">select</span> * from Student <span class="built_in">where</span> age&gt;=20 AND age &lt;= 30</span><br><span class="line"><span class="keyword">select</span> *from Student <span class="built_in">where</span> age BETWEEN 20 AND 30</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询年龄22岁，18岁，25岁的信息</span><br><span class="line">SELECT * FROM student <span class="built_in">where</span> age = 22 or age = 18 or age = 25</span><br><span class="line">SELECT * FROM student WHERE age IN (22,18,25);</span><br></pre></td></tr></table></figure><p> is not null(不为null值) 与 like（模糊查询）、distinct（去除重复值）<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 查询英语成绩不为null</span><br><span class="line">SELECT * FROM student WHERE english  IS NOT NULL;</span><br><span class="line"></span><br><span class="line"> _:单个任意字符</span><br><span class="line"> %：多个任意字符</span><br><span class="line">-- 查询姓马的有哪些？ like</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE <span class="string">&#x27;马%&#x27;</span>;</span><br><span class="line">-- 查询姓名第二个字是化的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE <span class="string">&quot;_化%&quot;</span>;</span><br><span class="line">-- 查询姓名是3个字的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE <span class="string">&#x27;___&#x27;</span>;</span><br><span class="line">-- 查询姓名中包含德的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE <span class="string">&#x27;%德%&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">-- 关键词 DISTINCT 用于返回唯一不同的值。</span><br><span class="line">-- 语法：SELECT DISTINCT 列名称 FROM 表名称</span><br><span class="line">SELECT DISTINCT NAME FROM  student ;</span><br></pre></td></tr></table></figure></p><h3 id="二-排序查询-order-by"><a href="#二-排序查询-order-by" class="headerlink" title="二 排序查询 order by"></a>二 排序查询 order by</h3><p> 语法：order by 子句</p><pre><code>      order by 排序字段1 排序方式1 ，排序字段2 排序方式2...</code></pre><p>注意：<br>            如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> -- 例子</span><br><span class="line">SELECT * FROM person ORDER BY math; --默认升序</span><br><span class="line">SELECT * FROM person ORDER BY math desc; --降序</span><br></pre></td></tr></table></figure><h3 id="三、-聚合函数：将一列数据作为一个整体，进行纵向的计算。"><a href="#三、-聚合函数：将一列数据作为一个整体，进行纵向的计算。" class="headerlink" title="三、 聚合函数：将一列数据作为一个整体，进行纵向的计算。"></a>三、 聚合函数：将一列数据作为一个整体，进行纵向的计算。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.count：计算个数</span><br><span class="line"></span><br><span class="line">2.max：计算最大值</span><br><span class="line"></span><br><span class="line">3.min：计算最小值</span><br><span class="line"></span><br><span class="line">4.<span class="built_in">sum</span>：计算和</span><br><span class="line"></span><br><span class="line">5.avg：计算平均数 </span><br></pre></td></tr></table></figure><h3 id="四、-分组查询-grout-by"><a href="#四、-分组查询-grout-by" class="headerlink" title="四、 分组查询 grout by"></a>四、 分组查询 grout by</h3><pre><code>  语法：group by 分组字段;  注意：分组之后查询的字段：分组字段、聚合函数</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-- 按照性别分组。分别查询男、女同学的平均分</span><br><span class="line">SELECT sex , AVG(math) FROM student GROUP BY sex;</span><br><span class="line"> </span><br><span class="line">-- 按照性别分组。分别查询男、女同学的平均分,人数</span><br><span class="line"> SELECT sex , AVG(math),COUNT(<span class="built_in">id</span>) FROM student GROUP BY sex;</span><br><span class="line"> </span><br><span class="line">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span><br><span class="line">SELECT sex , AVG(math),COUNT(<span class="built_in">id</span>) FROM student WHERE math &gt; 70 GROUP BY sex;</span><br><span class="line"> </span><br><span class="line"> --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人</span><br><span class="line">SELECT sex , AVG(math),COUNT(<span class="built_in">id</span>) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(<span class="built_in">id</span>) &gt; 2;</span><br><span class="line">SELECT sex , AVG(math),COUNT(<span class="built_in">id</span>) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</span><br></pre></td></tr></table></figure><h3 id="五、-分页查询"><a href="#五、-分页查询" class="headerlink" title="五、 分页查询"></a>五、 分页查询</h3><pre><code>1. 语法：limit 开始的索引,每页查询的条数;2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数3. limit 是一个MySQL&quot;方言&quot; </code></pre><p>– 每页显示3条记录<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student LIMIT 0,3; -- 第1页</span><br><span class="line"> </span><br><span class="line">SELECT * FROM student LIMIT 3,3; -- 第2页</span><br><span class="line"> </span><br><span class="line">SELECT * FROM student LIMIT 6,3; -- 第3页</span><br></pre></td></tr></table></figure></p><h3 id="六、内连接"><a href="#六、内连接" class="headerlink" title="六、内连接"></a>六、内连接</h3><h4 id="1-隐式内连接：使用where条件消除无用数据"><a href="#1-隐式内连接：使用where条件消除无用数据" class="headerlink" title="1.隐式内连接：使用where条件消除无用数据"></a>1.隐式内连接：使用where条件消除无用数据</h4><p>– 查询员工表的名称，性别。部门表的名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`<span class="built_in">id</span>`;</span><br><span class="line"> </span><br><span class="line">SELECT </span><br><span class="line">    t1.name, -- 员工表的姓名</span><br><span class="line">    t1.gender,-- 员工表的性别</span><br><span class="line">    t2.name -- 部门表的名称</span><br><span class="line">FROM</span><br><span class="line">    emp t1,</span><br><span class="line">    dept t2</span><br><span class="line">WHERE </span><br><span class="line">    t1.`dept_id` = t2.`<span class="built_in">id</span>`;</span><br></pre></td></tr></table></figure><h4 id="2-显式内连接"><a href="#2-显式内连接" class="headerlink" title="2.显式内连接"></a>2.显式内连接</h4><p>– 语法： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 from 表名1 [inner] <span class="built_in">join</span> 表名2 on 条件</span><br></pre></td></tr></table></figure><p>– 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`<span class="built_in">id</span>`;   </span><br><span class="line">SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`<span class="built_in">id</span>`; </span><br></pre></td></tr></table></figure><h3 id="七、外连接查询"><a href="#七、外连接查询" class="headerlink" title="七、外连接查询"></a>七、外连接查询</h3><p>1.左外连接 – 查询的是左表所有数据以及其交集部分。</p><p>– 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；<br>– 例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span><br><span class="line">SELECT  t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`<span class="built_in">id</span>`;</span><br><span class="line"> 2.右外连接  -- 查询的是右表所有数据以及其交集部分。</span><br><span class="line">-- 语法：</span><br><span class="line"><span class="keyword">select</span> 字段列表 from 表1 right [outer] <span class="built_in">join</span> 表2 on 条件；</span><br><span class="line">-- 例子：</span><br><span class="line">SELECT  * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`<span class="built_in">id</span>`;</span><br></pre></td></tr></table></figure><h3 id="八、子查询：查询中嵌套查询"><a href="#八、子查询：查询中嵌套查询" class="headerlink" title="八、子查询：查询中嵌套查询"></a>八、子查询：查询中嵌套查询</h3><p>– 查询工资最高的员工信息<br>– 1 查询最高的工资是多少 9000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(salary) FROM emp;</span><br></pre></td></tr></table></figure><p>– 2 查询员工信息，并且工资等于9000的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp WHERE emp.`salary` = 9000;</span><br><span class="line"> </span><br><span class="line"> -- 一条sql就完成这个操作。这就是子查询</span><br><span class="line">SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);</span><br><span class="line">   1.子查询的结果是单行单列的</span><br><span class="line"> 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</span><br><span class="line"></span><br><span class="line">-- 查询员工工资小于平均工资的人</span><br><span class="line">SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</span><br><span class="line">2. 子查询的结果是多行单列的：</span><br><span class="line">子查询可以作为条件，使用运算符<span class="keyword">in</span>来判断</span><br></pre></td></tr></table></figure><p>– 查询’财务部’和’市场部’所有的员工信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="built_in">id</span> FROM dept WHERE NAME = <span class="string">&#x27;财务部&#x27;</span> OR NAME = <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line">SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</span><br><span class="line"> 3. 子查询的结果是多行多列的：</span><br><span class="line">   子查询可以作为一张虚拟表参与查询</span><br><span class="line"></span><br><span class="line">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span><br><span class="line">-- 子查询</span><br><span class="line">SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; <span class="string">&#x27;2011-11-11&#x27;</span>) t2 WHERE t1.id = t2.dept_id;</span><br><span class="line"> </span><br><span class="line">-- 普通内连接</span><br><span class="line">SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`<span class="built_in">id</span>` AND t1.`join_date` &gt;  <span class="string">&#x27;2011-11-11&#x27;</span></span><br><span class="line">额外的一些知识</span><br><span class="line">AS关键字</span><br><span class="line">//将device_id做user_infors_example这个名字输出进行分页查询</span><br><span class="line"><span class="keyword">select</span> device_id as user_infors_example from user_profile <span class="built_in">limit</span> 0,2;</span><br><span class="line">这里主要是用到了 起别名关键字 as 以及组合限制查询 <span class="built_in">limit</span> 索引,个数</span><br><span class="line">其中as可以省略,索引为0可以省略</span><br><span class="line"><span class="keyword">select</span> device_id user_infors_example from user_profile <span class="built_in">limit</span> 2;</span><br></pre></td></tr></table></figure><p>查找除了复旦大学的所有学校</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># select device_id,gender,age,university from user_profile where university &lt;&gt; &#x27;复旦大学&#x27;</span></span><br><span class="line"><span class="comment"># select device_id,gender,age,university from user_profile where university != &#x27;复旦大学&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> device_id,gender,age,university from user_profile <span class="built_in">where</span> university NOT IN (<span class="string">&quot;复旦大学&quot;</span>)</span><br><span class="line">两次排序查询</span><br><span class="line"><span class="keyword">select</span> device_id,gpa,age from user_profile order by gpa,age</span><br><span class="line">先对gpa升序再对age升序</span><br></pre></td></tr></table></figure><p>先排序后限制条件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> gpa from user_profile <span class="built_in">where</span>  university=<span class="string">&quot;复旦大学&quot;</span> order by gpa desc <span class="built_in">limit</span> 1</span><br><span class="line">AVG算平均值 round可以用来给数组取小数点算数字的格式</span><br><span class="line">round(AVG(gpa),1)</span><br></pre></td></tr></table></figure><p>having和where的区别</p><p>1.where是可以直接对数据库中的字段做限制，having不行，having只能对前面提到的字段做限制，意思是having必须作为查全表的条件，而不能作为查个别字段的条件，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from goods <span class="built_in">where</span> goods_price&gt;10</span><br><span class="line"><span class="keyword">select</span> * from goods having goods_price&gt;10</span><br><span class="line">//这两者都可以</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> goods_name,goods_type from goods <span class="built_in">where</span> goods_price&gt;10</span><br><span class="line"><span class="keyword">select</span> goods_name,goods_type from goods having goods_price&gt;10(会报错！！！）</span><br><span class="line">//这里的话having就不行 如果要查的话需要再<span class="keyword">select</span>后面把所有字段加上</span><br></pre></td></tr></table></figure><p>2.where无法用替代名字做查询条件，而having可以，所以having一般出现在聚合函数中，例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> university,round(AVG(question_cnt),1) as avg_question_cnt,round(AVG(answer_cnt),1) as avg_answer_cnt from user_profile group by university </span><br><span class="line">HAVING</span><br><span class="line">avg_question_cnt&lt;5  or</span><br><span class="line">avg_answer_cnt&lt;20</span><br></pre></td></tr></table></figure><p>而且Having可以做聚合条件搜索，where不行，例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> goods_name,goods_type,avg（goods_price）  from goods having avg（goods_price）&gt;10</span><br><span class="line">查询商品平均价格大于10的</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 简历知识 </tag>
            
            <tag> sql </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/07/03/hello-world/"/>
      <url>/2024/07/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>们的世界会有不同<br>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
